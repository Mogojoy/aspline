# /**********************************************************************
# Rwrapper for BARSN v. 1.0 This program is free software; you can distribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation; either version 2, or (at your option) any
# later version.  These functions are distributed in the hope that they will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  The text of the GNU General Public License,
# version 2, is available as http://www.gnu.org/copyleft or by writing to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
# USA.  Credits and Acknowledgements: This Rwrapper is designed to work with
# Wallstrom and Kass's Barslib, (C) 2003.  Barslib uses Hansen and Kooperberg's
# Logspline, (C) 1997, as the default method for selecting initial knots.
# Barslib uses Bates and Venables Routines for manipulating B-splines, (C) 1998.
# The routines were released under the same GNU General Public License referred
# to above.
# ************************************************************************/
# /****************************************************************************
# barsN.fun(x,y,initial,iknots,prior,priorparam,burnin,sims,
# tau,c,fits,peak,conf) Prior to using this Rwrapper, one must have a shared
# object file called barsN.so.  This can be created on linux by giving the
# command R CMD SHLIB barsN.c Make sure that you have barsN.out before executing
# this command.  You must make the shared library available with the
# dyn.load('barsN.so',now=F) command.  Also, the barsN.c program must be properly
# compiled, with the compiled program saved as barsN.out.  WARNING: Please note
# that this program creates or overwrites several files, entitled 'bars_points',
# 'bars_params', 'samp_mu', 'samp_params', 'summ_mu', 'summ_mugrid',
# 'summ_params', 'prior_knots', and 'samp_knots'.  Care should be made to avoid
# accidentally deleting files.  This R wrapper for the BARS code has the
# following input: Required: x a vector of the independent variable, in
# increasing order y a vector of the dependent variable Optional: Initial knots
# settings (optional): iknots the initial number of knots for the spline (default
# = 25) Settings on prior for knots (optional): prior the type of prior being
# used for the knots (the only acceptable answers are 'Poisson', 'uniform', and
# 'user' - default = 'uniform') priorparam the parameter for the prior a) if
# using Poisson, the choice for lambda = mean b) if using Uniform, a vector of
# length 2 which includes the minimum number of knots followed by the maximum
# number of knots (default = c(1,60)) c) if using user-defined prior, a matrix
# with 2 columns.  The first column should be the number of knots and the second
# column should be the probability of obtaining this number of knots.  Note the
# following example: 2 0.05 3 0.15 4 0.30 5 0.30 6 0.10 7 0.10 MCMC settings
# (optional): burnin the desired length of the burn-in for the MCMC chain
# (default = 200) sims the number of simulations desired for the MCMC chain
# (default = 2000) tau parameter that controls the spread for the knot proposal
# distribution (default = 50.0) c parameter that controls the probability of
# birth and death candidates (default = 0.4) Output settings (optional): fits if
# 'T', the program will return the fitted values for each data point for each run
# of the simulation (default = T) Please note that if the number of data points
# and/or simulations is large, there may be a lengthy delay as the necessary data
# is read.  peak if 'T', the program will return the location and height of the
# highest point on the fitted curve (default = F) conf for use with peak.  Sets
# the limits for the credible intervals for the location and height of the peak.
# (default = 0.95 for 95% credible intervals).  Other settings (optional): bins
# the number of bins one desires the x-axis to be divided into - used to handle
# unbinned data and calculate posterior modes (default = 150) Note that due to
# the large amount of output generated by the program, it is desirable to save
# the results of the program into a variable, such as: out <-
# barsN.fun(x,y,.....)  The Rwrapper performs the operation by reading the data
# into the file 'bars_points', reading the settings into the file 'bars_params'
# and running the program in a linux setting.  The following information is
# returned in the output: postmeans vector of the posterior means evaluated at
# the x values postmodes vector of the posterior modes evaluated at the x values
# sims vector of each trial number, beginning at burnin + 1 and ending at burnin
# + sims no.knots vector of the number of knots used at each trial (does not
# include burnin iterations) sampknots matrix containing the position of the
# knots at each iteration.  Length of the matrix is equal to the number of
# iterations, not including burnin iterations, with the width of the matrix equal
# to the maximum number of knots at any iteration.  NAs are used to fill in the
# matrix at iteration numbers that have less than the maximum number of knots.
# sampBICs vector of the calculated BIC at each trial (does not include burnin
# iterations) sampllikes vector of the calculated loglikelihood at each trial
# (does not include burnin iterations) Optional output if fits = 'T': sampfits
# matrix of fits for each trial (does not include burnin iterations), with the
# rows of the matrix corresponding to the individual trial.  The columns
# represent the fits at each value of x.  Optional output if peak = 'T':
# samplpeaks vector of the x location of the highest point in the fitted curve
# for each trial (does not include burnin iterations) samphpeaks vector of the y
# value (height) of the highest point in the fitted curve for each trial (does
# not include burnin iterations) peaklocationquantile a credible interval for the
# x location of the highest peak; width of the interval is dependent upon the
# setting chosen for conf peaklocationmean the mean x location for the highest
# peak peaklocationmode the mode x location for the highest peak
# peakheightquantile a credible interval for the y value (height) of the highest
# peak; width of the interval is dependent upon the setting chosen for conf
# peakheightmean the mean y value (height) of the highest peak peakheightmode the
# mode y value (height) of the highest peak
# ****************************************************************************/
#' @export
barsN.fun <- function(x, y, iknots = 25, prior = "uniform", priorparam = c(1, 60),
    burnin = 200, sims = 2000, tau = 50, c = 0.4, fits = T, peak = F, conf = 0.95,
    bins = 150) {
    dyn.load("src/barsN.so")
    x <- as.double(x)
    y <- as.double(y)
    n <- length(x)
    n <- as.integer(n)
    if (length(y) != n) {
        print("x and y are not the same length")
        break
    }

    burnin <- as.integer(burnin)
    sims <- as.integer(sims)
    iknots <- as.integer(iknots)
    prior <- as.character(prior)
    tau <- as.double(tau)
    c <- as.double(c)
    if (c > 0.5 || c <= 0) {
        print("Value of c must be greater than 0 and no greater than 0.5")
        break
    }
    bins <- as.integer(bins)

    .C("filed", x, y, n)
    .C("priorsetup", burnin, sims, iknots, tau, c, conf, bins)
    z <- 0
    if (prior == "Poisson" || prior == "Pois" || prior == "poisson" || prior == "pois") {
        priorparam <- as.double(priorparam)
        .C("paramp", priorparam)
        z <- 1
    }

    if (prior == "Uniform" || prior == "Unif" || prior == "uniform" || prior == "unif") {
        if (length(priorparam) != 2) {
            print("Uniform prior requires a vector of length 2 - a minimum number")
            print("of knots and a maximum number of knots")
            break
        }
        upper <- priorparam[2]
        lower <- priorparam[1]
        if (lower > upper) {
            print("Lower bound is greater than upper bound for number of knots")
            break
        }
        if (lower < 1) {
            print("Lower bound is less than 1 and has been reset to 1 knot.")
            lower <- 1
        }
        upper <- as.integer(upper)
        lower <- as.integer(lower)
        .C("paramu", upper, lower)
        z <- 1
    }

    if (prior == "User" || prior == "user" || prior == "defined" || prior == "other" ||
        prior == "Other") {
        if (ncol(priorparam) != 2) {
            print("For user defined prior, priorparam must be of the form")
            print("of an nx2 matrix, with the number of knots in the first")
            print("column and the probability of obtaining that number of knots")
            print("in the second column.")
            break
        }
        pknots <- as.integer(priorparam[, 1])
        probknots <- as.double(priorparam[, 2])
        knotlength <- as.integer(length(pknots))
        .C("filed2", pknots, probknots, knotlength)
        .C("paramuser")
        z <- 2
    }

    if (z == 0) {
        print("Prior must be Poisson, uniform, or user-defined.")
        break
    }


    if (z == 1) {
        system("./barsN.out bars_points bars_params")
    }

    if (z == 2) {
        system("./barsN.out bars_points bars_params prior_file")
    }

    v <- scan("samp_params")
    if (length(v) == 0) {
        print("Program failed to generate correct knots.")
        print("Problem is likely due to poor constraints on prior.")
        print("Try again with smaller lower bound on prior.")
        break
    }

    sumfits <- as.matrix(read.table("summ_mu"))
    sampmeans <- as.matrix(read.table("samp_params"))
    summar <- as.matrix(read.table("summ_params"))
    lengths <- count.fields("samp_knots")
    knots1 <- scan("samp_knots")
    knots <- matrix(NA, ncol = max(lengths), nrow = length(lengths))
    index <- c(0, cumsum(lengths))
    for (i in 1:length(lengths)) {
        knots[i, 1:lengths[i]] <- knots1[(index[i] + 1):index[(i + 1)]]
    }


    if (fits == T) {
        sampfit <- as.matrix(read.table("samp_mu"))
        sampfit <- sampfit + (min(y) - 0.1)
        if (peak == T) {
            summar <- as.matrix(read.table("summ_params"))
            g <- list(sampfits = sampfit, postmeans = (sumfits[2, ]), postmodes = (sumfits[3,
                ]), sims = sampmeans[, 1], no.knots = sampmeans[, 6], sampknots = knots,
                sampBICs = sampmeans[, 2], sampllikes = sampmeans[, 3], samplpeaks = sampmeans[,
                  4], samphpeaks = (sampmeans[, 5]), peaklocationquantile = summar[1,
                  1:2], peaklocationmean = summar[1, 3], peaklocationmode = summar[1,
                  4], peakheightquantile = (summar[2, 1:2]), peakheightmean = (summar[2,
                  3]), peakheightmode = (summar[2, 4]))
        }
        if (peak == F) {
            g <- list(sampfits = sampfit, postmeans = (sumfits[2, ]), postmodes = (sumfits[3,
                ]), sims = sampmeans[, 1], no.knots = sampmeans[, 6], sampknots = knots,
                sampBICs = sampmeans[, 2], sampllikes = sampmeans[, 3])
        }
    }

    if (fits == F) {
        if (peak == T) {
            summar <- as.matrix(read.table("summ_params"))
            g <- list(postmeans = (sumfits[2, ]), postmodes = (sumfits[3, ]), sims = sampmeans[,
                1], no.knots = sampmeans[, 6], sampknots = knots, sampBICs = sampmeans[,
                2], sampllikes = sampmeans[, 3], samplpeaks = sampmeans[, 4], samphpeaks = (sampmeans[,
                5]), peaklocationquantile = summar[1, 1:2], peaklocationmean = summar[1,
                3], peaklocationmode = summar[1, 4], peakheightquantile = (summar[2,
                1:2]), peakheightmean = (summar[2, 3]), peakheightmode = (summar[2,
                4]))
        }
        if (peak == F) {
            g <- list(postmeans = (sumfits[2, ]), postmodes = (sumfits[3, ]), sims = sampmeans[,
                1], no.knots = sampmeans[, 6], sampknots = knots, sampBICs = sampmeans[,
                2], sampllikes = sampmeans[, 3])
        }
    }
    return(g)
}

